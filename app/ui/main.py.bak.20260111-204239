import os
import gradio as gr
from pathlib import Path
from datetime import datetime
from app.engine.chatterbox import ChatterboxEngine
from app.utils import (
    get_text_stats, format_duration, preprocess_text,
    get_text_presets, get_voice_metadata
)
from app.network import NetworkAuth, generate_shareable_urls

# Initialize Engine
engine = ChatterboxEngine()

# Initialize Network Auth
network_auth = NetworkAuth(Path("data"))

# Generation history (in-memory for this session)
generation_history = []


def _get_effective_port():
    config = network_auth.get_config()
    port = config["port"]
    env_port = os.environ.get("DEXTALKER_PORT")
    if env_port:
        try:
            port = int(env_port)
        except ValueError:
            pass
    return port


# Network Settings Handlers
def get_current_network_urls():
    """Get current shareable URLs."""
    port = _get_effective_port()
    urls = generate_shareable_urls(port)
    
    return (
        urls["localhost"] or "Not available",
        urls["lan"] or "No LAN IP detected",
        urls["tailscale"] or "No Tailscale IP detected",
        urls["magicDNS"] or "MagicDNS not available"
    )


def update_network_settings(lan_enabled, tailnet_enabled, tailnet_only, port, require_login):
    """Update network settings and return new URLs."""
    try:
        network_auth.update_config(
            lan_enabled=lan_enabled,
            tailnet_enabled=tailnet_enabled,
            tailnet_only=tailnet_only,
            port=int(port),
            require_login=require_login
        )
        
        # Get updated URLs
        localhost, lan, tailscale, magic = get_current_network_urls()
        
        status = "‚úÖ Settings updated. Restart required for changes to take effect."
        return status, localhost, lan, tailscale, magic
        
    except Exception as e:
        return f"‚ùå Failed to update settings: {str(e)}", *get_current_network_urls()


def regenerate_access_token_handler():
    """Regenerate the access token."""
    new_token = network_auth.regenerate_token()
    return f"‚úÖ New token generated: {new_token[:16]}...{new_token[-8:]}"


def get_network_status():
    """Get network connectivity status."""
    from app.network.utils import get_tailscale_status, check_port_available
    
    port = _get_effective_port()
    
    server_status = "‚óè Server Running" if check_port_available(port) == False else "‚óã Server Stopped"
    
    # Check Tailscale
    ts_status = get_tailscale_status()
    if ts_status["running"]:
        tailnet_status = "‚óè Tailnet Reachable"
    elif ts_status["installed"]:
        tailnet_status = f"‚óã Tailnet Offline ({ts_status.get('error', 'Not connected')})"
    else:
        tailnet_status = "‚óã Tailscale Not Installed"
    
    # LAN is assumed reachable if we have a non-localhost IP
    lan_ip = generate_shareable_urls(port)["lan"]
    lan_status = "‚óè LAN Reachable" if lan_ip else "‚óã No LAN Connection"
    
    return f"{server_status}\n{lan_status}\n{tailnet_status}"

# Starsilk Theme CSS
STARSILK_CSS = """
:root {
    --background: #0a0a0f;
    --surface: #12121a;
    --surface-elevated: #1a1a25;
    --primary: #ff6b00;
    --primary-hover: #ff8533;
    --text-primary: #f0f0f5;
    --text-secondary: #a0a0aa;
    --border: #2a2a35;
    --input-bg: #0f0f15;
    --success: #00ff88;
    --warning: #ffaa00;
    --danger: #ff4b4b;
}

body, .gradio-container {
    background-color: var(--background) !important;
    color: var(--text-primary) !important;
    font-family: 'Inter', system-ui, -apple-system, sans-serif;
}

.contain {
    background-color: var(--background) !important;
}

.starsilk-panel {
    background: var(--surface) !important;
    border: 1px solid var(--border) !important;
    border-radius: 12px !important;
    padding: 20px !important;
}

textarea, input {
    background-color: var(--input-bg) !important;
    border: 1px solid var(--border) !important;
    color: var(--text-primary) !important;
    border-radius: 8px !important;
}

button.primary {
    background: var(--primary) !important;
    border: none !important;
    color: white !important;
    font-weight: 600 !important;
}
button.primary:hover {
    background: var(--primary-hover) !important;
}

.text-stat {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}

.text-stat.green { color: var(--success); }
.text-stat.yellow { color: var(--warning); }
.text-stat.red { color: var(--danger); }

footer { display: none !important; }
button[aria-label="Settings"],
button[aria-label="Language"],
#settings-button,
.settings-button {
    display: none !important;
}
"""


def _load_voice_choices():
    return engine.get_available_voices()


def get_engine_status_display():
    """Get formatted engine status for UI display."""
    status = engine.get_engine_status()
    provider = status["provider"]
    device = status["device"]
    fallback = status["fallback_mode"]
    
    if fallback:
        return "‚ö†Ô∏è **Fallback Mode** (Chatterbox not available)"
    else:
        return f"‚úÖ **{provider}** on `{device}` | {status['available_voices_count']} voices"


def update_text_stats(text):
    """Update character/word count and estimated duration."""
    if not text:
        return "0 chars | 0 words | 0s"
    
    chars, words, duration = get_text_stats(text)
    
    # Color code based on length
    if chars < 500:
        css_class = "green"
    elif chars < 1000:
        css_class = "yellow"
    else:
        css_class = "red"
    
    return f'<span class="text-stat {css_class}">{chars} chars | {words} words | ~{format_duration(duration)}</span>'


def apply_preprocessing(text, remove_urls, remove_special):
    """Apply text preprocessing and return cleaned text."""
    if not text:
        return text
    return preprocess_text(text, remove_urls, remove_special)


def load_preset(preset_name):
    """Load a text preset."""
    presets = get_text_presets()
    return presets.get(preset_name, "")


async def synthesize_handler(text, voice, remove_urls, remove_special, progress=gr.Progress()):
    """Generate speech from text."""
    if not text:
        return None, "‚ö†Ô∏è Please enter text to synthesize.", gr.update(), gr.update()

    # Preprocess text
    processed_text = preprocess_text(text, remove_urls, remove_special)
    if not processed_text:
        return None, "‚ö†Ô∏è Text is empty after preprocessing.", gr.update(), gr.update()

    progress(0, desc="Generating speech...")
    file_path, status = await engine.synthesize(processed_text, voice)
    progress(1, desc="Complete!")

    if file_path:
        # Add to history
        history_entry = {
            "text": processed_text[:100] + ("..." if len(processed_text) > 100 else ""),
            "voice": voice,
            "file": file_path,
            "timestamp": datetime.now().strftime("%H:%M:%S")
        }
        generation_history.insert(0, history_entry)
        if len(generation_history) > 10:
            generation_history.pop()
        
        history_display = format_history()
        
        return file_path, f"‚úÖ Ready: {Path(file_path).name}", file_path, history_display
    return None, f"‚ùå {status}", gr.update(), gr.update()


def format_history():
    """Format generation history for display."""
    if not generation_history:
        return []
    
    formatted = []
    for entry in generation_history:
        formatted.append({
            "Time": entry["timestamp"],
            "Voice": entry["voice"],
            "Text": entry["text"],
            "File": Path(entry["file"]).name
        })
    return formatted


def replay_from_history(history_table, evt: gr.SelectData):
    """Replay audio from history when row is clicked."""
    if not generation_history or evt.index[0] >= len(generation_history):
        return None
    
    entry = generation_history[evt.index[0]]
    return entry["file"]


async def record_voice_handler(duration_sec, progress=gr.Progress()):
    progress(0, desc=f"Recording for {int(duration_sec)}s...")
    path, status = await engine.record_voice_sample(duration_sec)
    progress(1, desc="Complete!")
    
    if path:
        return path, f"‚úÖ {status}"
    return None, f"‚ùå {status}"


async def add_voice_handler(voice_name, voice_upload, recorded_path):
    source_path = recorded_path or voice_upload
    if not source_path:
        return "‚ùå Record or upload a voice sample.", gr.update(), gr.update(), gr.update()

    success, msg = await engine.add_voice(voice_name, source_path)
    choices = _load_voice_choices()
    new_value = voice_name if voice_name in choices else (choices[0] if choices else None)
    status_prefix = "‚úÖ" if success else "‚ùå"
    
    # Update metadata
    metadata = get_voice_metadata_table()
    
    return f"{status_prefix} {msg}", gr.update(choices=choices, value=new_value), choices, metadata


def get_voice_metadata_table():
    """Get voice metadata as table."""
    voices_dir = engine.voices_dir
    metadata = []
    
    for voice_file in sorted(voices_dir.glob("*.wav")):
        meta = get_voice_metadata(voice_file)
        metadata.append({
            "Voice": voice_file.stem,
            "Duration": meta["duration"],
            "Size": meta["size"],
            "Added": meta["date_added"]
        })
    
    return metadata


def refresh_voices_handler():
    choices = _load_voice_choices()
    metadata = get_voice_metadata_table()
    return gr.update(choices=choices, value=choices[0] if choices else None), choices, metadata


with gr.Blocks(css=STARSILK_CSS, title="DexTalker") as demo:
    gr.Markdown("# üéôÔ∏è DexTalker")
    gr.Markdown(get_engine_status_display())
    gr.Markdown("üí° **Quick Tip**: Press Ctrl/Cmd+Enter in the text box to generate speech")

    with gr.Tabs():
        with gr.TabItem("Studio"):
            with gr.Row():
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("### Generator")
                    
                    # Preset selector
                    preset_choices = list(get_text_presets().keys())
                    preset_dropdown = gr.Dropdown(
                        choices=["(None)"] + preset_choices,
                        label="üìù Text Presets",
                        value="(None)"
                    )
                    
                    txt_input = gr.Textbox(
                        label="Input Text",
                        lines=5,
                        placeholder="Type here to speak... (Ctrl/Cmd+Enter to generate)",
                        value="Welcome to DexTalker. The stars are silent, but we are not."
                    )
                    
                    # Text stats
                    text_stats = gr.HTML(update_text_stats(txt_input.value))
                    
                    # Preprocessing options
                    with gr.Accordion("üîß Text Preprocessing", open=False):
                        remove_urls_check = gr.Checkbox(label="Remove URLs", value=False)
                        remove_special_check = gr.Checkbox(label="Remove special characters", value=False)

                    voice_choices = _load_voice_choices()
                    voice_sel = gr.Dropdown(
                        choices=voice_choices,
                        label="Voice",
                        value=voice_choices[0] if voice_choices else None,
                    )
                    
                    btn_generate = gr.Button("üéôÔ∏è Generate Speech (Ctrl+Enter)", variant="primary")
                    status_gen = gr.Textbox(label="Status", interactive=False, max_lines=1)
                    audio_gen_out = gr.Audio(label="Generated Output", interactive=False, type="filepath")
                    
                    # Copy to clipboard button
                    output_path_display = gr.Textbox(label="Output Path", interactive=False, max_lines=1)
                    with gr.Row():
                        copy_btn = gr.Button("üìã Copy Path", size="sm")
                        
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("### üìú Generation History")
                    gr.Markdown("Click on any row to replay the audio")
                    history_table = gr.Dataframe(
                        headers=["Time", "Voice", "Text", "File"],
                        datatype=["str", "str", "str", "str"],
                        value=[],
                        interactive=False,
                    )
                    history_audio = gr.Audio(label="History Playback", interactive=False, type="filepath", visible=False)

        with gr.TabItem("Voices"):
            gr.Markdown("### Record or Upload a Voice Sample")
            gr.Markdown("Recording uses the system microphone; upload works everywhere.")

            with gr.Row():
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("#### Record Sample")
                    record_duration = gr.Slider(
                        minimum=2,
                        maximum=20,
                        step=1,
                        value=6,
                        label="Recording Length (seconds)",
                    )
                    btn_record = gr.Button("üé§ Record Sample", variant="primary")
                    record_status = gr.Textbox(label="Record Status", interactive=False, max_lines=1)
                    record_preview = gr.Audio(label="Recorded Sample", interactive=False, type="filepath")

                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("#### Upload Sample")
                    voice_upload = gr.File(label="Voice Sample (.wav)", file_types=[".wav"], type="filepath")

                    gr.Markdown("#### Register Voice")
                    voice_name = gr.Textbox(label="Voice Name", placeholder="e.g. Commander Shepard")
                    btn_add_voice = gr.Button("‚ûï Register Voice", variant="primary")
                    status_voice = gr.Textbox(label="Status", interactive=False)

            gr.Markdown("### üìä Voice Library")
            with gr.Row():
                voice_metadata_table = gr.Dataframe(
                    headers=["Voice", "Duration", "Size", "Added"],
                    datatype=["str", "str", "str", "str"],
                    value=get_voice_metadata_table(),
                    label="Voice Metadata"
                )
            
            with gr.Row():
                voice_manifest = gr.JSON(value=_load_voice_choices(), label="Available Voices")
                btn_refresh_voices = gr.Button("üîÑ Refresh Voices")

        with gr.TabItem("üé¨ Video Voice Clone"):
            gr.Markdown("### Create Voice Profile from Video")
            gr.Markdown("Upload a video, trim to select the speech segment, and create a voice clone profile.")
            
            with gr.Row():
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("#### 1Ô∏è‚É£ Upload Video")
                    video_upload = gr.Video(
                        label="Video File (MP4, MOV, WebM)",
                        sources=["upload"]
                    )
                    video_info_display = gr.Textbox(
                        label="Video Info",
                        interactive=False,
                        max_lines=2
                    )
                    
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("#### 2Ô∏è‚É£ Trim Segment")
                    gr.Markdown("Select the portion of video containing clear speech (3-30 seconds)")
                    
                    with gr.Row():
                        trim_start = gr.Number(
                            label="Start Time (seconds)",
                            value=0,
                            minimum=0,
                            precision=2
                        )
                        trim_end = gr.Number(
                            label="End Time (seconds)",
                            value=10,
                            minimum=0,
                            precision=2
                        )
                    
                    trim_duration_display = gr.Textbox(
                        label="Segment Duration",
                        value="10.00 seconds",
                        interactive=False,
                        max_lines=1
                    )
            
            gr.Markdown("---")
            
            with gr.Row():
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("#### 3Ô∏è‚É£ Consent & Profile Details")
                    
                    # Consent section with warning
                    gr.Markdown("""
                    ‚ö†Ô∏è **Voice Cloning Ethics & Safety**
                    
                    Voice cloning technology should only be used ethically and legally:
                    - You must have explicit consent from the person whose voice you're cloning
                    - Do not create voices of public figures without permission  
                    - Do not use cloned voices for fraud, impersonation, or deception
                    - Respect privacy and intellectual property rights
                    """)
                    
                    consent_checkbox = gr.Checkbox(
                        label="I confirm I have the rights and consent to use this voice",
                        value=False,
                        info="Required before creating voice profile"
                    )
                    
                    video_voice_name = gr.Textbox(
                        label="Voice Profile Name",
                        placeholder="e.g. John Doe Professional",
                        max_lines=1
                    )
                    
                    video_voice_notes = gr.Textbox(
                        label="Notes (optional)",
                        placeholder="e.g. Source: interview footage, 2024",
                        lines=2
                    )
                    
                    btn_create_video_voice = gr.Button(
                        "‚ú® Create Voice Profile",
                        variant="primary",
                        size="lg"
                    )
                    
                    video_voice_status = gr.Textbox(
                        label="Status",
                        interactive=False,
                        max_lines=3
                    )
                
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("#### 4Ô∏è‚É£ Test Voice")
                    gr.Markdown("After creating the profile, test it with a sample phrase")
                    
                    test_text_input = gr.Textbox(
                        label="Test Text",
                        value="This is a test of the voice cloning system.",
                        lines=3
                    )
                    
                    btn_test_video_voice = gr.Button("üéôÔ∏è Test Voice", variant="secondary")
                    
                    test_audio_output = gr.Audio(
                        label="Test Output",
                        interactive=False,
                        type="filepath"
                    )
                    
                    test_status_display = gr.Textbox(
                        label="Test Status",
                        interactive=False,
                        max_lines=1
                    )

        with gr.TabItem("‚öôÔ∏è Network Access"):
            gr.Markdown("### Network Access Settings")
            gr.Markdown("Enable LAN or Tailnet access to share DexTalker with other devices")
            
            with gr.Row():
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("#### Access Control")
                    
                    net_lan_enabled = gr.Checkbox(
                        label="Enable LAN Access",
                        value=network_auth.config["lan_enabled"],
                        info="Allow access from devices on your local Wi-Fi/Ethernet"
                    )
                    
                    net_tailnet_enabled = gr.Checkbox(
                        label="Enable Tailnet Access",
                        value=network_auth.config["tailnet_enabled"],
                        info="Allow access from devices on your Tailscale network"
                    )
                    
                    net_tailnet_only = gr.Checkbox(
                        label="Tailnet-Only Mode (Recommended)",
                        value=network_auth.config["tailnet_only"],
                        info="Require all remote connections to come from Tailscale"
                    )
                    
                    net_port = gr.Number(
                        label="Port",
                        value=network_auth.config["port"],
                        precision=0
                    )
                    
                    net_require_login = gr.Checkbox(
                        label="Require Login on New Device",
                        value=network_auth.config["require_login"],
                        info="Recommended for security"
                    )
                    
                    btn_update_network = gr.Button("üíæ Save Settings", variant="primary")
                    net_status = gr.Textbox(
                        label="Status",
                        interactive=False,
                        max_lines=2
                    )
                
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("#### Shareable Addresses")
                    gr.Markdown("Copy these URLs to share DexTalker with other devices")
                    
                    localhost_url, lan_url, ts_url, magic_url = get_current_network_urls()
                    
                    gr.Markdown("**Localhost** (this machine only)")
                    with gr.Row():
                        net_localhost_url = gr.Textbox(
                            value=localhost_url,
                            interactive=False,
                            show_label=False,
                            max_lines=1
                        )
                        btn_copy_localhost = gr.Button("üìã Copy", size="sm")
                    
                    gr.Markdown("**Local Network** (Wi-Fi/Ethernet)")
                    gr.Markdown("_Share with devices on same network_")
                    with gr.Row():
                        net_lan_url = gr.Textbox(
                            value=lan_url,
                            interactive=False,
                            show_label=False,
                            max_lines=1
                        )
                        btn_copy_lan = gr.Button("üìã Copy", size="sm")
                    
                    gr.Markdown("**Tailnet** (Tailscale)")
                    gr.Markdown("_Share with devices on your Tailscale network_")
                    with gr.Row():
                        net_tailscale_url = gr.Textbox(
                            value=ts_url,
                            interactive=False,
                            show_label=False,
                            max_lines=1
                        )
                        btn_copy_tailscale = gr.Button("üìã Copy", size="sm")
                    
                    if magic_url != "MagicDNS not available":
                        gr.Markdown("**MagicDNS** (Easier to remember)")
                        with gr.Row():
                            net_magic_url = gr.Textbox(
                                value=magic_url,
                                interactive=False,
                                show_label=False,
                                max_lines=1
                            )
                            btn_copy_magic = gr.Button("üìã Copy", size="sm")
            
            with gr.Row():
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("#### Access Token")
                    gr.Markdown("Share this token with trusted users who need remote access")
                    
                    net_access_token = gr.Textbox(
                        label="Token",
                        value=f"{network_auth.access_token[:20]}...{network_auth.access_token[-12:]}",
                        interactive=False,
                        max_lines=1
                    )
                    
                    with gr.Row():
                        btn_copy_token = gr.Button("üìã Copy Full Token")
                        btn_regen_token = gr.Button("üîÑ Regenerate", variant="secondary")
                    
                    net_token_status = gr.Textbox(
                        label="Token Status",
                        interactive=False,
                        max_lines=1
                    )
                
                with gr.Column(elem_classes="starsilk-panel"):
                    gr.Markdown("#### Connection Status")
                    
                    net_connection_status = gr.Textbox(
                        label="Status",
                        value=get_network_status(),
                        interactive=False,
                        lines=3
                    )
                    
                    btn_refresh_status = gr.Button("üîÑ Refresh Status")

    # Event handlers
    txt_input.change(update_text_stats, inputs=[txt_input], outputs=[text_stats])
    
    preset_dropdown.change(
        lambda preset: load_preset(preset) if preset != "(None)" else "",
        inputs=[preset_dropdown],
        outputs=[txt_input]
    )
    
    btn_generate.click(
        synthesize_handler,
        inputs=[txt_input, voice_sel, remove_urls_check, remove_special_check],
        outputs=[audio_gen_out, status_gen, output_path_display, history_table],
    )
    
    # Keyboard shortcut: Ctrl+Enter to generate
    txt_input.submit(
        synthesize_handler,
        inputs=[txt_input, voice_sel, remove_urls_check, remove_special_check],
        outputs=[audio_gen_out, status_gen, output_path_display, history_table],
    )
    
    copy_btn.click(
        lambda path: gr.Info(f"Copied: {path}") if path else gr.Warning("No path to copy"),
        inputs=[output_path_display],
        outputs=[]
    )
    
    history_table.select(
        replay_from_history,
        inputs=[history_table],
        outputs=[history_audio]
    )

    btn_record.click(
        record_voice_handler,
        inputs=[record_duration],
        outputs=[record_preview, record_status],
    )

    btn_add_voice.click(
        add_voice_handler,
        inputs=[voice_name, voice_upload, record_preview],
        outputs=[status_voice, voice_sel, voice_manifest, voice_metadata_table],
    )

    btn_refresh_voices.click(
        refresh_voices_handler,
        outputs=[voice_sel, voice_manifest, voice_metadata_table],
    )
    
    # Video Voice Clone tab handlers
    video_upload.change(
        inputs=[video_upload],
        outputs=[video_info_display]
    )
    
    trim_start.change(
        inputs=[trim_start, trim_end],
        outputs=[trim_duration_display]
    )
    
    trim_end.change(
        inputs=[trim_start, trim_end],
        outputs=[trim_duration_display]
    )
    
    btn_create_video_voice.click(
        inputs=[
            video_upload,
            trim_start,
            trim_end,
            video_voice_name,
            video_voice_notes,
            consent_checkbox
        ],
        outputs=[video_voice_status, voice_sel, voice_metadata_table]
    )
    
    btn_test_video_voice.click(
        inputs=[video_voice_name, test_text_input],
        outputs=[test_audio_output, test_status_display]
    )
    
    # Network settings handlers
    btn_update_network.click(
        update_network_settings,
        inputs=[net_lan_enabled, net_tailnet_enabled, net_tailnet_only, net_port, net_require_login],
        outputs=[net_status, net_localhost_url, net_lan_url, net_tailscale_url, net_magic_url]
    )
    
    btn_copy_localhost.click(lambda: gr.Info("Copied localhost URL"), outputs=[])
    btn_copy_lan.click(lambda: gr.Info("Copied LAN URL"), outputs=[])
    btn_copy_tailscale.click(lambda: gr.Info("Copied Tailscale URL"), outputs=[])
    
    btn_regen_token.click(regenerate_access_token_handler, outputs=[net_token_status])
    btn_refresh_status.click(get_network_status, outputs=[net_connection_status])

if __name__ == "__main__":
    # Get network configuration
    config = network_auth.get_config()
    bind_addr = config["bind_address"]
    port = _get_effective_port()
    
    logger.info(f"Launching DexTalker on {bind_addr}:{port}")
    demo.launch(server_name=bind_addr, server_port=port)

# Network Settings Handlers

def get_current_network_urls():
    """Get current shareable URLs."""
    port = _get_effective_port()
    urls = generate_shareable_urls(port)
    
    return (
        urls["localhost"] or "Not available",
        urls["lan"] or "No LAN IP detected",
        urls["tailscale"] or "No Tailscale IP detected",
        urls["magicDNS"] or "MagicDNS not available"
    )


def update_network_settings(lan_enabled, tailnet_enabled, tailnet_only, port, require_login):
    """Update network settings and return new URLs."""
    try:
        network_auth.update_config(
            lan_enabled=lan_enabled,
            tailnet_enabled=tailnet_enabled,
            tailnet_only=tailnet_only,
            port=int(port),
            require_login=require_login
        )
        
        # Get updated URLs
        localhost, lan, tailscale, magic = get_current_network_urls()
        
        status = "‚úÖ Settings updated. Restart required for changes to take effect."
        return status, localhost, lan, tailscale, magic
        
    except Exception as e:
        return f"‚ùå Failed to update settings: {str(e)}", *get_current_network_urls()


def regenerate_access_token_handler():
    """Regenerate the access token."""
    new_token = network_auth.regenerate_token()
    return f"‚úÖ New token generated: {new_token[:16]}...{new_token[-8:]}"


def copy_url_handler(url):
    """Handler for copy button - just shows notification."""
    return gr.Info(f"Copied: {url}")


def get_network_status():
    """Get network connectivity status."""
    from app.network.utils import get_tailscale_status, check_port_available
    
    port = _get_effective_port()
    
    server_status = "‚óè Server Running" if check_port_available(port) == False else "‚óã Server Stopped"
    
    # Check Tailscale
    ts_status = get_tailscale_status()
    if ts_status["running"]:
        tailnet_status = "‚óè Tailnet Reachable"
    elif ts_status["installed"]:
        tailnet_status = f"‚óã Tailnet Offline ({ts_status.get('error', 'Not connected')})"
    else:
        tailnet_status = "‚óã Tailscale Not Installed"
    
    # LAN is assumed reachable if we have a non-localhost IP
    lan_ip = generate_shareable_urls(port)["lan"]
    lan_status = "‚óè LAN Reachable" if lan_ip else "‚óã No LAN Connection"
    
    return f"{server_status}\n{lan_status}\n{tailnet_status}"
